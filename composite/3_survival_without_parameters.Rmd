
```{r source survival_without_parameters, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}
suppressPackageStartupMessages(source("setup.R"))
```

# - Analyse de survie

Notre base de donn√©es comporte une variable temporelle de dur√©e de survie caract√©ris√© par :

- `marriage_duration_years` : Mesure la **Dur√©e du mariage** de l'individu.

De plus, nous introduisons une variable \(a\) correspondant √† la borne inf√©rieure de la variable de survie. Ici, pour `marriage_duration_years`, on a \(a = 1\). Cette formalisation permet d‚Äôunifier la notation et de clarifier les domaines de d√©finition dans les d√©veloppements th√©oriques ult√©rieurs.

On pose $X$ la variable al√©atoire de survenue de l'√©v√®nement d'int√©r√™t, donc le divorce. On note donc les diff√©rentes fonctions de survie et leurs interpr√©tations par le tableau suivant :

```{r survival_without_parameters_0, echo = FALSE, fig.align='center'}


# D√©finition des colonnes
fonctions <- c("$S(t)$", "$H(t)$", "$h(t)$")

definitions <- c(
  "$S(t) = \\mathbb{P}(X \\gt t) = e^{-H(t)} = e^{-\\int_a^t h(u)\\,du}$",
  "$H(t) = \\int_a^t h(u)\\,du = -\\ln S(t)$",
  "$h(t) = -\\dfrac{S'(t)}{S(t)}$"
)

premier_temps <- c(
  "Probabilit√© que le mariage dure ‚â• t",
  "Risque cumul√© de divorce jusqu‚Äô√† t",
  "Risque instantan√© de divorce √† t"
)


# Cr√©ation du tableau
tableau <- data.frame(
  Fonction = fonctions,
  D√©finition = definitions,
  Dur√©e_du_mariage = premier_temps,
  stringsAsFactors = FALSE
)

# Affichage avec kable
kable(tableau, "html", caption = "üìä Interpr√©tation et d√©finitions des fonctions de survie", align = c("c","c","c","c")) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE
  ) %>%
  column_spec(1, bold = TRUE, background = "#D6EAF8") %>%
  column_spec(2, background = "#EBF5FB") %>%
  column_spec(3, background = "#FDEBD0") %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")

```

Nos donn√©es comportent une censure : certains individus n'ont pas encore connu l'√©v√©nement d'int√©r√™t, c'est √† dire qu'ils sont toujours encore mari√©s. Cette information est d√©j√† inscrite dans la base de donn√©es via la variable **`divorced`**, qui indique si l'individu est divorc√© ou non que l'on note :


$$
\delta_i =
\begin{cases}
1 & \text{si l'√©v√©nement divorce est observ√© pour } i \\
0 & \text{si l'observation n'est pas divorc√©}
\end{cases}
$$

## Censure

Soit \(X_i\) le temps de survie r√©el de l'individu \(i\) (dur√©e jusqu'√† l'√©v√©nement d'int√©r√™t, ici le divorce), et \(C_i\) la **variable al√©atoire du temps de censure**, repr√©sentant le moment auquel l'individu quitte l'√©tude ou n'a pas encore subi l'√©v√©nement.  

La dur√©e r√©ellement observ√©e pour chaque individu d√©pend du type de censure :  

- **Censure √† droite** : 
\[
T_i = \min(X_i, C_i)
\]
- **Censure √† gauche** : 
\[
T_i = \max(X_i, C_i)
\]

### Censure √† droite
La censure √† droite se produit lorsqu'un individu **n'a pas encore subi l'√©v√©nement d'int√©r√™t** (ici le divorce) au moment de sa derni√®re observation (\(X_i > C_i\)).  
Les principaux types de censure √† droite sont :  

- **Type I (fixe)** : tous les individus sont censur√©s au m√™me moment pr√©d√©termin√©.  
- **Type II** : l'√©tude s'arr√™te d√®s qu'un certain nombre d'√©v√©nements est observ√©.  
- **Type III (al√©atoire)** : le moment de censure varie d'un individu √† l'autre, par exemple √† cause de la fin de suivi variable, de pertes de vue ou d'arr√™ts de participation. Ce type est le plus courant dans les √©tudes observationnelles.

### Censure √† gauche
La censure √† gauche se produit lorsque l'√©v√©nement **a eu lieu avant le d√©but de l'observation**, et on ne conna√Æt que la borne sup√©rieure du temps de survie (\(X_i < C_i\)).  
Elle est beaucoup plus rare dans les √©tudes humaines et moins souvent trait√©e dans la litt√©rature.

### Censure par intervalle
Une censure par intervalle survient lorsqu‚Äôon sait seulement que l‚Äô√©v√©nement s‚Äôest produit **entre deux dates d‚Äôobservation**. Dans la pratique, elle est souvent convertie en censure √† droite pour simplifier l'analyse.

---

Dans notre base de donn√©es, certains mariages **n'ont pas abouti √† un divorce au moment de la fin de l'√©tude**, et le temps de suivi varie selon les individus.  
On en d√©duit que les donn√©es pr√©sentent une **censure √† droite de type III (al√©atoire)**.  
On suppose que cette censure est **non informative**, c'est-√†-dire ind√©pendante de la probabilit√© de divorce, conform√©ment aux hypoth√®ses classiques des mod√®les de survie.  

Dans ce contexte, la **dur√©e r√©ellement observ√©e** pour chaque mariage est donn√©e par :

\[
T = \min(X, C)
\]

## - Estimateur de la Fonction de survie S(t)

**Estimateur empirique de la fonction de survie :**

$$
\hat{S}(t) = \frac{1}{n} \sum_{i=1}^{n} \boldsymbol{1}_{\{t_i > t\}}
$$

- \( n \) = nombre total d'observations  
- \( t_i \) = temps jusqu‚Äô√† l‚Äô√©v√©nement pour l‚Äôindividu \( i \)  
- \( \boldsymbol{1}_{\{t_i > t\}} \) = indicateur qui vaut 1 si l‚Äôindividu n‚Äôa pas encore eu l‚Äô√©v√©nement √† \( t \), 0 sinon  

Cet estimateur correspond simplement √† la proportion d‚Äôindividus encore mari√©s au temps \( t \).  
Il suppose qu‚Äôil **n‚Äôy a aucune donn√©e censur√©e**, c‚Äôest-√†-dire que tous les individus ont eu l‚Äô√©v√©nement observ√©.

```{r survival_without_parameters_1, echo = FALSE, fig.align='center'}
# Tableau Kaplan‚ÄìMeier SANS CENSURE (variance binomiale)
km_methods_no_censor <- data.frame(
  M√©thode = c(
    "Estimateur empirique de survie (sans censure)",
    "Variance (loi binomiale, cas sans censure)",
    "Intervalle de confiance plain √† 95 %"
  ),
  
  Formule = c(
    # Kaplan‚ÄìMeier simplifi√© sans censure
    "$\\hat{S}(t)=\\frac{1}{n}\\sum_{i=1}^{n}\\mathbf{1}_{\\{t_i\\gt t\\}}$",
    # Variance binomiale
    "$\\widehat{\\text{Var}}[\\hat{S}(t)] = \\frac{\\hat S(t) (1 - \\hat S(t))}{n}$",
    
    # IC plain
    "$\\text{IC}_{95\\%}(t) = \\hat S(t) \\pm 1.96 \\sqrt{\\widehat{\\text{Var}}[\\hat S(t)]}$"
  ),
  
  Description = c(
    "Dans le cas sans censure, Kaplan‚ÄìMeier co√Øncide avec l‚Äôestimateur empirique de la fonction de survie.",
    "Variance estim√©e selon la loi binomiale, adapt√©e aux donn√©es enti√®rement observ√©es.",
    "Intervalle de confiance classique bas√© sur la variance binomiale."
  ),
  
  stringsAsFactors = FALSE
)

# Affichage du tableau
kable(km_methods_no_censor, "html", escape = FALSE,
      caption = "üìä Estimateur de survie sans censure, variance binomiale et intervalle de confiance plain √† 95 %",
      align = c("c","c","c")) %>%
  kable_styling(bootstrap_options = c("striped","hover","condensed"), full_width = FALSE) %>%
  column_spec(1, bold = TRUE, color = "black",
              background = c("#D6EAF8", "#F9E79F", "#FDEDEC")) %>%
  column_spec(2, width = "6cm") %>%
  column_spec(3, width = "8cm") %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")

```


---

## - Estimateur avec censure (Kaplan-Meier)

L'estimateur de Kaplan-Meier d√©coule de l'id√©e suivante : survivre apr√®s un temps \(t_n\) revient √† √™tre vivant juste avant \(t_n\) et **ne pas subir l'√©v√©nement √† ce temps**. Formellement, pour \(t_0 < t_1 < \dots < t_{n-1} < t_n\) :

La probabilit√© de survie jusqu‚Äô√† \(t_n\) peut s‚Äô√©crire en utilisant la **r√®gle de multiplication des probabilit√©s**‚ÄØ:

\[
\mathbb{P}(X > t_n) = \mathbb{P}(X > t_1, X > t_2, \dots, X > t_n)
\]

On introduit une r√©currence‚ÄØ: pour tout \(k \ge 1\),

\[
\mathbb{P}(X > t_k \mid X > t_{k-1}, \dots, X > t_1) = \mathbb{P}(X > t_k \mid X > t_{k-1})
\]

o√π l‚Äô√©galit√© d√©coule de l‚Äôind√©pendance conditionnelle induite par l‚Äôordre croissant des temps.  

Ainsi, par r√©currence sur les indices \(k\) :

\[
\begin{aligned}
\mathbb{P}(X > t_1, X > t_2, \dots, X > t_n) 
&= \mathbb{P}(X > t_1) \cdot \mathbb{P}(X > t_2 \mid X > t_1) \\
&\quad \cdot \mathbb{P}(X > t_3 \mid X > t_1, X > t_2) \cdots \mathbb{P}(X > t_n \mid X > t_1, \dots, X > t_{n-1}) \\
&= \mathbb{P}(X > t_1) \prod_{k=2}^{n} \mathbb{P}(X > t_k \mid X > t_{k-1})
\end{aligned}
\]

On consid√®re les temps d‚Äô√©v√©nements distincts \(T_{(1)} < T_{(2)} < \dots < T_{(j)}\) (d√©c√®s ou divorce observ√©s) rang√©s par ordre croissant.  
On d√©finit \(T_{(0)} = 0\), la borne inf√©rieure du temps (par exemple \(a=1\) pour la dur√©e de mariage).  

Ainsi, la probabilit√© de survie jusqu‚Äôau temps \(T_{(j)}\) peut s‚Äô√©crire comme un **produit de probabilit√©s conditionnelles** :

\[
\begin{aligned}
\mathbb{P}(X > T_{(j)}) 
&= \prod_{k=1}^{j} \mathbb{P}(X > T_{(k)} \mid X > T_{(k-1)})
\end{aligned}
\]

Pour chaque temps d‚Äô√©v√©nement \(T_{(k)}\), on s‚Äôint√©resse √† la probabilit√© conditionnelle de **subir l‚Äô√©v√©nement √† ce temps**, sachant que l‚Äôindividu √©tait encore √† risque juste avant :

\[
\mathbb{P}(X \le T_{(k)} \mid X > T_{(k-1)})
\]

Cette quantit√© repr√©sente la probabilit√© qu‚Äôun individu qui a ¬´ surv√©cu ¬ª jusqu‚Äô√† \(T_{(k-1)}\) subisse l‚Äô√©v√©nement √† \(T_{(k)}\).  

En pratique, on dispose des donn√©es observ√©es :  

- \(n_k\) = nombre d‚Äôindividus **encore √† risque** juste avant \(T_{(k)}\)  
- \(d_k\) = nombre d‚Äô√©v√©nements observ√©s √† \(T_{(k)}\)  

On peut alors **estimer cette probabilit√© conditionnelle** par :

\[
\hat{\mathbb{P}}(X \le T_{(k)} \mid X > T_{(k-1)}) = \frac{d_k}{n_k}
\]

La probabilit√© de **survivre** au temps \(T_{(k)}\) est le compl√©mentaire :

\[
\hat{q}_k = \hat{\mathbb{P}}(X \ge T_{(k)} \mid X > T_{(k-1)}) = 1 - \hat{\mathbb{P}}(X \le T_{(k)} \mid X > T_{(k-1)}) = 1 - \frac{d_k}{n_k}
\]

Enfin, en rempla√ßant les probabilit√©s conditionnelles dans le produit de survie, on obtient l‚Äô**estimateur de Kaplan-Meier** (ou produit-limite) :

\[
\hat{S}(t) = \prod_{T_{(k)} \le t} \hat{q}_k = \prod_{T_{(k)} \le t} \left( 1 - \frac{d_k}{n_k} \right)
\]

Ainsi, l‚Äôestimateur de Kaplan-Meier **corrige naturellement le biais d√ª √† la censure** et fournit une estimation non param√©trique de la fonction de survie.

```{r survival_without_parameters_2, echo = FALSE, fig.align='center'}
# Tableau Kaplan-Meier + variance + intervalle de confiance (log)
km_methods <- data.frame(
  M√©thode = c(
    "Kaplan-Meier",
    "Variance de Greenwood",
    "Intervalle de confiance log √† 95 %"
  ),
  
  Formule = c(
    # Kaplan‚ÄìMeier
    "$\\hat{S}(t) = \\prod_{T_{(k)} \\le t} \\left( 1 - \\dfrac{d_k}{n_k} \\right)$",
    
    # Greenwood
    "$\\widehat{\\text{Var}}\\left[\\hat{S}(t)\\right] 
      = \\hat{S}(t)^2 
      \\sum_{T_{(k)} \\le t} 
      \\dfrac{d_k}{n_k (n_k - d_k)}$",
    
    # Intervalle log
    "$\\text{IC}_{95\\%}(t) = \\hat S(t) \\pm 1.96 \\sqrt{\\widehat{\\text{Var}}[\\hat S(t)]}$"

  ),
  
  Description = c(
    "Estimateur non param√©trique de la fonction de survie bas√© sur les √©v√©nements observ√©s et le nombre d'individus √† risque.",
    "Variance estim√©e de Kaplan-Meier selon la formule de Greenwood.",
    "Intervalle de confiance construit via une transformation logarithmique de S(t), qui est la m√©thode 'plain' de survfit()."
  ),
  
  stringsAsFactors = FALSE
)

# Affichage tableau
kable(km_methods, "html", escape = FALSE,
      caption = "üìä Estimateur de Kaplan-Meier, variance de Greenwood et intervalle de confiance log √† 95 %",
      align = c("c","c","c")) %>%
  kable_styling(bootstrap_options = c("striped","hover","condensed"), full_width = FALSE) %>%
  column_spec(1, bold = TRUE, color = "black",
              background = c("#D6EAF8", "#F9E79F", "#FDEDEC")) %>%
  column_spec(2, width = "6cm") %>%
  column_spec(3, width = "8cm") %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")


```


```{r survival_without_parameters_3, echo = FALSE, fig.align='center'}
# --- Donn√©es
time <- data.brute$marriage_duration_years
event <- data.brute$divorced

# --- Survie sans censure avec IC
surv_no_censor <- survfit(Surv(time, rep(1, length(time))) ~ 1, conf.type = "plain")
surv_no_censor$lower[is.na(surv_no_censor$lower)] <- 0
surv_no_censor$upper[is.na(surv_no_censor$upper)] <- 0

n_no <- length(surv_no_censor$time)

# --- Survie avec censure avec IC
surv_censor <- survfit(Surv(time, event) ~ 1, conf.type = "plain")

# --- Plotly avec IC et legendgroup ---
fig <- plot_ly() %>%
  
  # --- Sans censure ---
  add_ribbons(x = surv_no_censor$time,
              ymin = surv_no_censor$lower,
              ymax = surv_no_censor$upper,
              fillcolor = "#1f78b433",
              line = list(color = "transparent"),
              legendgroup = "nocens",
              showlegend = FALSE) %>%
  add_lines(x = surv_no_censor$time,
            y = surv_no_censor$surv,
            name = "Sans censure",
            line = list(color = "#1f78b4", width = 2),
            legendgroup = "nocens",
            showlegend = TRUE) %>%
  
  # --- Avec censure ---
  add_ribbons(x = surv_censor$time,
              ymin = surv_censor$lower,
              ymax = surv_censor$upper,
              fillcolor = "#e31a1c33",
              line = list(color = "transparent"),
              legendgroup = "cens",
              showlegend = FALSE) %>%
  add_lines(x = surv_censor$time,
            y = surv_censor$surv,
            name = "Avec censure",
            line = list(color = "#e31a1c", width = 2),
            legendgroup = "cens",
            showlegend = TRUE) %>%
  
  # --- Layout ---
  layout(title = "Comparaison des fonctions de survie : sans et avec censure",
         xaxis = list(title = "Dur√©e du mariage (ann√©es)"),
         yaxis = list(title = "Probabilit√© de rester mari√©"),
         legend = list(x = 0.80, y = 0.95))

div(style="text-align:center;", fig)


```

## Estimateur de survie avec covariables

Dans cette section, nous √©valuons la fonction de survie en fonction de diff√©rentes variables explicatives afin de d√©terminer si certains groupes ont une influence sur la courbe de survie de Kaplan‚ÄìMeier. 

Nous r√©aliserons des tests d'hypoth√®ses pour v√©rifier si les courbes de survie diff√®rent significativement entre les groupes. 

En particulier, nous utiliserons des tests tels que le **Log-Rank** ou le **test de Gehan‚ÄìWilcoxon**, selon le type de covariable √©tudi√©e.


```{r survival_without_parameters_4, echo = FALSE, fig.align='center'}
# --- Donn√©es
time1 <- data.brute$marriage_duration_years[data.brute$mental_health_issues==0]
event1 <- data.brute$divorced[data.brute$mental_health_issues==0]

time2 <- data.brute$marriage_duration_years[data.brute$mental_health_issues==1]
event2 <- data.brute$divorced[data.brute$mental_health_issues==1]


# --- Survie avec censure avec IC
surv_censor1 <- survfit(Surv(time1, event1) ~ 1, conf.type = "plain")
surv_censor2 <- survfit(Surv(time2, event2) ~ 1, conf.type = "plain")

# --- Plotly avec IC et legendgroup ---
fig <- plot_ly() %>%

  # --- sans infid√©it√©
  add_ribbons(x = surv_censor1$time,
              ymin = surv_censor1$lower,
              ymax = surv_censor1$upper,
              fillcolor = "#e31a1c33",
              line = list(color = "transparent"),
              legendgroup = "noinfi",
              showlegend = FALSE) %>%
  add_lines(x = surv_censor1$time,
            y = surv_censor1$surv,
            name = "Sans probl√®me de sant√© mentale",
            line = list(color = "#e31a1c", width = 2),
            legendgroup = "noinfi",
            showlegend = TRUE) %>%
  
  # --- Avec infid√©lit√©
  add_ribbons(x = surv_censor2$time,
              ymin = surv_censor2$lower,
              ymax = surv_censor2$upper,
              fillcolor = "#1f78b433",
              line = list(color = "transparent"),
              legendgroup = "infi",
              showlegend = FALSE) %>%
  add_lines(x = surv_censor2$time,
            y = surv_censor2$surv,
            name = "Avec probl√®me de sant√© mentale",
            line = list(color = "#1f78b4", width = 2),
            legendgroup = "infi",
            showlegend = TRUE) %>%
  
  # --- Layout ---
  layout(title = "Fonctions de survie de Kaplan Meier sans et avec probl√®me de sant√© mentale",
         xaxis = list(title = "Dur√©e du mariage (ann√©es)"),
         yaxis = list(title = "Probabilit√© de rester mari√©"),
         legend = list(x = 0.80, y = 0.95))

div(style="text-align:center;", fig)

```

Dans ce graphique, les courbes de survie ont √©t√© s√©par√©es selon la pr√©sence ou l'absence d'un probl√®me de sant√© mentale.  

Nous posons les hypoth√®ses suivantes pour comparer les groupes :

$$
\begin{cases}
H_0 : S_1(t) = S_2(t), & \text{pour tout } t \\
H_1 : S_1(t) \neq S_2(t), & \text{pour au moins un } t
\end{cases}
$$

o√π \(S_1(t)\) est la fonction de survie pour les individus **sans probl√®me de sant√© mentale** et \(S_2(t)\) pour ceux **avec probl√®me de sant√© mentale**.  

Pour tester ces hypoth√®ses, nous appliquons le **test du Log-Rank**, qui permet de comparer les fonctions de survie entre groupes.


On cherche √† tester l‚Äôhypoth√®se‚ÄØ:  

$$
H_0 : S_A(t) = S_B(t) \quad \forall t,
$$

c‚Äôest-√†-dire que les fonctions de survie des deux groupes sont identiques. Sous $H_0$, la proportion attendue de d√©c√®s parmi les sujets √† risque est la m√™me dans les deux groupes √† chaque instant de d√©c√®s $T_i$.

Pour chaque temps $T_i$ :  

- $D_{Ai}$ : nombre d‚Äô√©v√©nements (d√©c√®s) observ√©s dans le groupe $A$  
- $D_{Bi}$ : nombre d‚Äô√©v√©nements dans le groupe $B$  
- $d_i = D_{Ai} + D_{Bi}$ : nombre total d‚Äô√©v√©nements √† $T_i$  
- $n_{Ai}$, $n_{Bi}$, $n_i = n_{Ai}+n_{Bi}$ : nombre d‚Äôindividus √† risque dans chaque groupe et total  

Sous $H_0$, $D_{Ai}$ suit une loi hyperg√©om√©trique avec :  

$$
\text{Esp√©rance : } E(D_{Ai}) = \frac{n_{Ai} \, d_i}{n_i}, \qquad
\text{Variance : } V(D_{Ai}) = \frac{(n_i - d_i)}{n_i - 1} \frac{d_i n_{Ai} n_{Bi}}{n_i^2}
$$

Ainsi, les √©carts $D_{Ai} - E(D_{Ai})$ suivent asymptotiquement une loi normale :  

$$
D_{Ai} - E(D_{Ai}) \sim \mathcal{N}(0, V(D_{Ai}))
$$

et  

$$
\frac{(D_{Ai} - E(D_{Ai}))^2}{V(D_{Ai})} \sim \chi^2_1 \quad \text{(asymptotiquement)}.
$$


Soient des pond√©rations $w_i$ pour chaque temps $T_i$ :  

$$
U = \sum_{i=1}^{N} w_i \, (D_{Ai} - E(D_{Ai}))
$$

Alors, sous $H_0$, $U$ suit asymptotiquement une loi normale :  

$$
U \sim \mathcal{N}\Big(0, \sum_{i=1}^{N} w_i^2 V(D_{Ai}) \Big)
$$

La statistique de test associ√©e :  

$$
\chi^2_0 = \frac{\Big( \sum_{i=1}^{N} w_i (D_{Ai} - E(D_{Ai})) \Big)^2}{\sum_{i=1}^{N} w_i^2 V(D_{Ai})} \sim \chi^2_1 \quad \text{(asymptotiquement)}
$$

- **Test du Log-Rank** : $w_i = 1$  
  - Poids √©gaux pour tous les d√©c√®s, peu importe le temps.  
- **Test de Gehan** : $w_i = n_i$  
  - Poids plus √©lev√©s pour les d√©c√®s pr√©coces.  
- **Test de Peto-Prentice** :  
$$
w_i = \prod_{k=1}^{i} \frac{n_k}{n_k + d_k}
$$  
  - Poids inspir√©s de l‚Äôestimateur Kaplan‚ÄìMeier, favorisant aussi les √©v√©nements pr√©coces.  

**Remarques importantes :**  
1. Les tests sont valides uniquement si les courbes de survie ne se croisent pas.  
2. Le Log-Rank est le test le plus couramment utilis√© en pratique.  
3. Il existe des versions approch√©es du Log-Rank pour des calculs manuels.





```{r survival_without_parameters_5, echo = FALSE, }
# vecteurs concat√©n√©s
time  <- c(time1, time2)
event <- c(event1, event2)

# facteur groupe
group <- factor(c(
  rep("no_mental_health_issue", length(time1)),
  rep("mental_health_issue", length(time2))
))

# test du log-rank (khi-deux)
res <- survdiff(Surv(time, event) ~ group, rho = 0)
res
```


```{r survival_without_parameters_6, echo = FALSE, fig.align='center'}
# --- Donn√©es
time1 <- data.brute$marriage_duration_years[data.brute$education_level=="Bachelor"]
event1 <- data.brute$divorced[data.brute$education_level=="Bachelor"]

time2 <- data.brute$marriage_duration_years[data.brute$education_level=="High School"]
event2 <- data.brute$divorced[data.brute$education_level=="High School"]

time3 <- data.brute$marriage_duration_years[data.brute$education_level=="Master"]
event3 <- data.brute$divorced[data.brute$education_level=="Master"]

time4 <- data.brute$marriage_duration_years[data.brute$education_level=="PhD"]
event4 <- data.brute$divorced[data.brute$education_level=="PhD"]

time5 <- data.brute$marriage_duration_years[data.brute$education_level=="No Formal Education"]
event5 <- data.brute$divorced[data.brute$education_level=="No Formal Education"]


# --- Survie avec censure avec IC
surv_censor1 <- survfit(Surv(time1, event1) ~ 1, conf.type = "plain")
surv_censor2 <- survfit(Surv(time2, event2) ~ 1, conf.type = "plain")
surv_censor3 <- survfit(Surv(time3, event3) ~ 1, conf.type = "plain")
surv_censor4 <- survfit(Surv(time4, event4) ~ 1, conf.type = "plain")
surv_censor5 <- survfit(Surv(time5, event5) ~ 1, conf.type = "plain")

cols <- c(
  "Bachelor" = "#1f77b4",
  "High School" = "#e31a1c",
  "Master" = "#33a02c",
  "PhD" = "#ff7f00",
  "No Formal Education" = "#6a3d9a"
)


# --- Plotly avec IC et legendgroup ---
fig <- plot_ly() %>%
  
  # Bachelor
  add_ribbons(
    x = surv_censor1$time,
    ymin = surv_censor1$lower,
    ymax = surv_censor1$upper,
    fillcolor = paste0(cols["Bachelor"], "33"),
    line = list(color = "transparent"),
    legendgroup = "Bachelor",
    showlegend = FALSE
  ) %>%
  add_lines(
    x = surv_censor1$time,
    y = surv_censor1$surv,
    name = "Bachelor",
    line = list(color = cols["Bachelor"], width = 2),
    legendgroup = "Bachelor",
    showlegend = TRUE
  ) %>%
  
  # High School
  add_ribbons(
    x = surv_censor2$time,
    ymin = surv_censor2$lower,
    ymax = surv_censor2$upper,
    fillcolor = paste0(cols["High School"], "33"),
    line = list(color = "transparent"),
    legendgroup = "High School",
    showlegend = FALSE
  ) %>%
  add_lines(
    x = surv_censor2$time,
    y = surv_censor2$surv,
    name = "High School",
    line = list(color = cols["High School"], width = 2),
    legendgroup = "High School",
    showlegend = TRUE
  ) %>%
  
  # Master
  add_ribbons(
    x = surv_censor3$time,
    ymin = surv_censor3$lower,
    ymax = surv_censor3$upper,
    fillcolor = paste0(cols["Master"], "33"),
    line = list(color = "transparent"),
    legendgroup = "Master",
    showlegend = FALSE
  ) %>%
  add_lines(
    x = surv_censor3$time,
    y = surv_censor3$surv,
    name = "Master",
    line = list(color = cols["Master"], width = 2),
    legendgroup = "Master",
    showlegend = TRUE
  ) %>%
  
  # PhD
  add_ribbons(
    x = surv_censor4$time,
    ymin = surv_censor4$lower,
    ymax = surv_censor4$upper,
    fillcolor = paste0(cols["PhD"], "33"),
    line = list(color = "transparent"),
    legendgroup = "PhD",
    showlegend = FALSE
  ) %>%
  add_lines(
    x = surv_censor4$time,
    y = surv_censor4$surv,
    name = "PhD",
    line = list(color = cols["PhD"], width = 2),
    legendgroup = "PhD",
    showlegend = TRUE
  ) %>%
  
  # No formal education
  add_ribbons(
    x = surv_censor5$time,
    ymin = surv_censor5$lower,
    ymax = surv_censor5$upper,
    fillcolor = paste0(cols["No Formal Education"], "33"),
    line = list(color = "transparent"),
    legendgroup = "No Formal Education",
    showlegend = FALSE
  ) %>%
  add_lines(
    x = surv_censor5$time,
    y = surv_censor5$surv,
    name = "No formal education",
    line = list(color = cols["No Formal Education"], width = 2),
    legendgroup = "No Formal Education",
    showlegend = TRUE
  ) %>%
  
  layout(
    title = "Fonctions de survie par niveau d'√©ducation",
    xaxis = list(title = "Dur√©e du mariage (ann√©es)"),
    yaxis = list(title = "Probabilit√© de rester mari√©"),
    legend = list(x = 0.80, y = 0.95)
  )

div(style="text-align:center;", fig)

```

```{r survival_without_parameters_7, echo = FALSE}

```


```{r survival_without_parameters_8, echo = FALSE, }
# vecteurs concat√©n√©s
time  <- c(time4, time5)
event <- c(event4, event5)

# facteur groupe
group <- factor(c(
  rep("PhD", length(time4)),
  rep("No Formal Education", length(time5))
))

# test du log-rank (khi-deux)
res <- survdiff(Surv(time, event) ~ group, rho = 0)
res


```

## - Estimateur de Nelson-Aalen

L‚Äôestimateur de **Nelson-Aalen** permet d‚Äôestimer le **risque cumulatif** \(h(t)\) dans le cadre de donn√©es censur√©es.

On d√©finit‚ÄØ:

- \(H(t) = \mathbb{P}(T > t) = \mathbb{P}(X > t, C > t) = \mathbb{P}(X > t)\mathbb{P}(C > t)= S(t) G(t)\)  o√π \(G\) est la fonction de survie de la censure \(C\)  


- \(H_1(t) = \mathbb{P}(T > t, \delta = 1) = \mathbb{P}(X > t, C > X)\)  

On peut √©crire \(H_1(t)\) en fonction de la densit√© \(f(u)\) de \(X\) et de \(G(u)\) :

\[
\begin{aligned}
H_1(t) &= \mathbb{P}(X > t,\, C > X) \\
&= \mathbb{E}\big[ \mathbf{1}_{\{X > t\}} \cdot \mathbf{1}_{\{C > X\}} \big] \\[6pt]
&= \mathbb{E}\Big[ \mathbf{1}_{\{X > t\}} \, \mathbb{E}\big[\mathbf{1}_{\{C > X\}}\mid X\big] \Big] \\[6pt]
&= \mathbb{E}\big[ \mathbf{1}_{\{X > t\}} \, \mathbb{P}(C > X \mid X) \big] \\[6pt]
&= \mathbb{E}\big[ \mathbf{1}_{\{X > t\}} \, G(X^-) \big] \\[6pt]
&= \displaystyle \int_{t}^{\infty} G(u^-) \, f(u)\,du \\[6pt]
&= - \displaystyle \int_{t}^{\infty} G(u^-) \, dS(u)
\end{aligned}
\]

On obtient donc :

\[ 
dH_1(t) = G(t^{-})dS(t)
\]

Et donc par le temps on obtient :

\[ 
\frac{dH_1(t)}{dt} = \frac{G(t^{-})dS(t)}{dt}
\]

ce qui donne math√©matiquement :

\[ 
H_1'(t) = G(t^{-})S'(t)
\]

Ainsi on a :

\[
\begin{aligned}
\hat{H}_{NA}(t) &= \displaystyle \int_{0}^{t} h(u) \, du \\[2mm]
&= \displaystyle \int_{0}^{t} -\frac{S'(u)}{S(u)} \, du \\[2mm]
&= \displaystyle \int_{0}^{t} -\frac{\frac{H_1(u)}{G(u^{-})}}{\frac{H(u)}{G(u)}} \, du \\[2mm]
&= \displaystyle \int_{0}^{t} -\frac{H_1(u)}{H(u)}\frac{G(u)}{G(u^{-})} \, du \\[2mm]
&= \displaystyle \int_{0}^{t} -\frac{H_1(u)}{H(u)} \, du
\end{aligned}
\]

Un estimateur *naturel* s‚Äôobtient en rempla√ßant les fonctions \(H\) et \(H_1\) par leurs √©quivalents empiriques (calculables car les variables \(T\) et \(\delta\) sont observ√©es):

\[
\hat{H}(u) = \frac{1}{n} \sum_{i=1}^{n} \mathbf{1}_{\{T_i > u\}}, \quad
\hat{H}_1(u) = \frac{1}{n} \sum_{i=1}^{n} \mathbf{1}_{\{T_i > u, \delta_i = 1\}}
\]

L‚Äôestimateur de Nelson-Aalen est alors donn√© par‚ÄØ:

\[
\hat{H}_{NA}(t) = \displaystyle \int_{0}^{t} - \frac{\displaystyle \sum_{i=1}^{n} \mathbf{1}_{\{T_i > u, \delta_i = 1\}}}{\displaystyle \sum_{i=1}^{n} \mathbf{1}_{\{T_i > u\}}} \, du 
\]

Comme \(T\) est √† temps discret, l‚Äôint√©grale devient une **somme sur les temps d‚Äô√©v√©nement distincts**¬†, et on d√©finit alors pour chaque temps d‚Äô√©v√©nement \(t_i\)¬†:

\[
d_i = \sum_{j=1}^{n} \mathbf{1}_{\{T_j = t_i, \delta_j = 1\}}, 
\quad
n_i = \sum_{j=1}^{n} \mathbf{1}_{\{T_j \ge t_i\}}.
\]

Ce qui donne :

\[
\hat{H}_{NA}(t) = \sum_{t_i \le t} \frac{d_i}{n_i}.
\]


---

Une autre fa√ßon de calculer la fonction de risque cumul√©e et de passer par l'estimateur de beslow. 

\subsection*{3.1 Estimateur de Breslow du risque cumul√©}

Rappel : l'estimateur de Kaplan‚ÄìMeier de la fonction de survie s'√©crit, pour des temps d'√©v√©nement distincts \(t_1<\dots<t_m\),
\[
\hat{S}(t)=\prod_{t_i\le t}\left(1-\frac{d_i}{n_i}\right),
\]
o√π \(d_i\) est le nombre d'√©v√©nements au temps \(t_i\) et \(n_i\) le nombre d'individus √† risque juste avant \(t_i\).

En utilisant la relation
\[
H(t)=-\log S(t),
\]
on obtient l'estimateur de Breslow du risque cumul√© :
\[
\hat{H}_{\text{Breslow}}(t) 
= -\log\big(\hat{S}(t)\big)
= -\log\!\left(\prod_{t_i\le t}\left(1-\frac{d_i}{n_i}\right)\right)
= -\sum_{t_i\le t} \log\!\left(1-\frac{d_i}{n_i}\right).
\]

\bigskip

\textbf{Lien avec Nelson‚ÄìAalen.} Pour des fractions \(d_i/n_i\) petites, on utilise l'approximation
\(\log(1-x)\approx -x\) pour \(x\) proche de \(0\). Ainsi
\[
\sum_{t_i\le t}\log\!\left(1-\frac{d_i}{n_i}\right)
\approx \sum_{t_i\le t}\frac{d_i}{n_i},
\]
**Ce qui montre que l'estimateur de Breslow est proche (et asymptotiquement √©quivalent) √† l'estimateur de Nelson‚ÄìAalen**
\(\hat{H}_{NA}(t)=\sum_{t_i\le t}\dfrac{d_i}{n_i}\) lorsque les sauts sont petits.


```{r survival_without_parameters_9, echo = FALSE, fig.align='center'}
# --- Tableau combin√© Nelson-Aalen + Breslow + Variance ---
risk_methods <- data.frame(
  M√©thode = c("Nelson-Aalen", "Breslow"),
  Formule = c(
    "$\\hat{H}_{NA}(t) = \\sum_{t_k \\le t} \\dfrac{d_k}{n_k}$",
    "$\\hat{H}_{\\text{Breslow}}(t) = - \\sum_{t_k \\le t} \\log\\left(1 - \\dfrac{d_k}{n_k}\\right)$"
  ),
  Variance = c(
    "$\\text{Var}(\\hat{H}_{NA}(t)) = \\sum_{t_k \\le t} \\dfrac{d_k}{n_k^2}$",
    "$\\text{Var}(\\hat{H}_{\\text{Breslow}}(t)) = \\sum_{t_k \\le t} \\dfrac{d_k}{n_k(n_k - d_k)}$"
  ),
  Description = c(
    "Estimateur non param√©trique bas√© sur les √©v√©nements observ√©s et le nombre de sujets √† risque.",
    "Estimateur du risque cumulatif d√©riv√© de $H(t) = -\\log(S(t))$ via l'estimateur de Kaplan-Meier."
  ),
  stringsAsFactors = FALSE
)

kable(risk_methods, "html", escape = FALSE,
      caption = "üìä M√©thodes d‚Äôestimation du risque cumulatif : Nelson-Aalen et Breslow",
      align = c("c","c","c","c")) %>%
  kable_styling(bootstrap_options = c("striped","hover","condensed"), full_width = FALSE) %>%
  
  # Style colonne M√©thode
  column_spec(1, bold = TRUE, color = "black", background = c("#D6EAF8", "#F9E79F")) %>%
  
  # Largeur colonnes
  column_spec(2, width = "5.5cm") %>%
  column_spec(3, width = "5.5cm") %>%
  column_spec(4, width = "8cm") %>%
  
  # Style ligne d'en-t√™te
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")


```


```{r survival_without_parameters_10, echo = FALSE, fig.align='center'}
# --- Donn√©es ---
time  <- data.brute$marriage_duration_years
event <- data.brute$divorced

# --- 1Ô∏è‚É£ Avec censure ---
km_cens <- survfit(Surv(time, event) ~ 1)

# Nelson-Aalen
H_NA_cens <- cumsum(km_cens$n.event / km_cens$n.risk)
se_H_NA_cens <- sqrt(cumsum(km_cens$n.event / (km_cens$n.risk^2)))
df_NA_cens <- data.frame(
  time = km_cens$time,
  H = H_NA_cens,
  lower = H_NA_cens - 1.96 * se_H_NA_cens,
  upper = H_NA_cens + 1.96 * se_H_NA_cens
)

# Breslow
km_bres_cens <- survfit(Surv(time, event) ~ 1, type = "kaplan-meier")
df_Bres_cens <- data.frame(
  time = km_bres_cens$time,
  H = -log(km_bres_cens$surv),
  lower = -log(km_bres_cens$upper),
  upper = -log(km_bres_cens$lower)
)

# --- 2Ô∏è‚É£ Sans censure ---
km_nocens <- survfit(Surv(time, rep(1,length(time))) ~ 1)

# Nelson-Aalen
H_NA_nocens <- cumsum(km_nocens$n.event / km_nocens$n.risk)
se_H_NA_nocens <- sqrt(cumsum(km_nocens$n.event / (km_nocens$n.risk^2)))
df_NA_nocens <- data.frame(
  time = km_nocens$time,
  H = H_NA_nocens,
  lower = H_NA_nocens - 1.96 * se_H_NA_nocens,
  upper = H_NA_nocens + 1.96 * se_H_NA_nocens
)

# Breslow
km_bres_nocens <- survfit(Surv(time, rep(1,length(time))) ~ 1, type = "kaplan-meier")
df_Bres_nocens <- data.frame(
  time = km_bres_nocens$time,
  H = -log(km_bres_nocens$surv),
  lower = -log(km_bres_nocens$upper),
  upper = -log(km_bres_nocens$lower)
)

# --- Plot Plotly avec IC et legendgroup ---
fig <- plot_ly() %>%
  
  # --- Avec censure ---
  # Nelson-Aalen
  add_ribbons(data = df_NA_cens, x = ~time, ymin = ~lower, ymax = ~upper,
              fillcolor = "rgba(255,0,0,0.2)", line = list(color = 'transparent'),
              legendgroup = "NA_cens", showlegend = FALSE) %>%
  add_lines(data = df_NA_cens, x = ~time, y = ~H,
            line = list(color = "red", width = 2),
            name = "Nelson-Aalen avec censure",
            legendgroup = "NA_cens", showlegend = TRUE) %>%
  
  # Breslow
  add_ribbons(data = df_Bres_cens, x = ~time, ymin = ~lower, ymax = ~upper,
              fillcolor = "rgba(0,0,255,0.2)", line = list(color = 'transparent'),
              legendgroup = "Bres_cens", showlegend = FALSE) %>%
  add_lines(data = df_Bres_cens, x = ~time, y = ~H,
            line = list(color = "blue", width = 2),
            name = "Breslow avec censure",
            legendgroup = "Bres_cens", showlegend = TRUE) %>%
  
  # --- Sans censure ---
  # Nelson-Aalen
  add_ribbons(data = df_NA_nocens, x = ~time, ymin = ~lower, ymax = ~upper,
              fillcolor = "rgba(255,165,0,0.2)", line = list(color = 'transparent'),
              legendgroup = "NA_nocens", showlegend = FALSE) %>%
  add_lines(data = df_NA_nocens, x = ~time, y = ~H,
            line = list(color = "orange", width = 2),
            name = "Nelson-Aalen sans censure",
            legendgroup = "NA_nocens", showlegend = TRUE) %>%
  
  # Breslow
  add_ribbons(data = df_Bres_nocens, x = ~time[-length(df_Bres_nocens$time)],
              ymin = ~lower[-length(df_Bres_nocens$lower)],
              ymax = ~upper[-length(df_Bres_nocens$upper)],
              fillcolor = "rgba(0,128,0,0.2)", line = list(color = 'transparent'),
              legendgroup = "Bres_nocens", showlegend = FALSE) %>%
  add_lines(data = df_Bres_nocens, x = ~time[-length(df_Bres_nocens$time)],
            y = ~H[-length(df_Bres_nocens$H)],
            line = list(color = "green", width = 2),
            name = "Breslow sans censure",
            legendgroup = "Bres_nocens", showlegend = TRUE) %>%
  
  # --- Layout ---
  layout(
    title = "Risque cumulatif : avec et sans censure (Nelson-Aalen & Breslow)",
    xaxis = list(title = "Dur√©e du mariage (ann√©es)"),
    yaxis = list(title = "Risque cumulatif H(t)"),
    legend = list(orientation = "v", x = 0.1, y = 1)
  )

div(style="text-align:center;", fig)

```

### - Estimateur de la fonction du risque instann√© (Nelson-Aalen)

```{r survival_without_parameters_11, echo = FALSE, fig.align='center'}
# --- Donn√©es ---
time <- data.brute$marriage_duration_years
event <- data.brute$divorced

# --- Hazard instantan√© Nelson-Aalen avec censure ---
fit_cens <- survfit(Surv(time, event) ~ 1)
h_cens <- fit_cens$n.event / fit_cens$n.risk
se_h_cens <- sqrt(fit_cens$n.event / (fit_cens$n.risk^2))
df_cens <- data.frame(
  time = fit_cens$time,
  hazard = h_cens,
  lower = h_cens - 1.96 * se_h_cens,
  upper = h_cens + 1.96 * se_h_cens
)

# --- Hazard instantan√© Nelson-Aalen sans censure ---
fit_nocens <- survfit(Surv(time, rep(1, length(time))) ~ 1)
h_nocens <- fit_nocens$n.event / fit_nocens$n.risk
se_h_nocens <- sqrt(fit_nocens$n.event / (fit_nocens$n.risk^2))
df_nocens <- data.frame(
  time = fit_nocens$time,
  hazard = h_nocens,
  lower = h_nocens - 1.96 * se_h_nocens,
  upper = h_nocens + 1.96 * se_h_nocens
)

# --- Plotly avec IC et legendgroup ---
fig <- plot_ly() %>%
  # Ribbon Sans censure
  add_ribbons(data = df_nocens, x = ~time, ymin = ~lower, ymax = ~upper,
              fillcolor = 'rgba(0,0,255,0.2)', line = list(color = 'transparent'),
              legendgroup = "nocens", showlegend = FALSE) %>%
  # Courbe centrale Sans censure
  add_trace(data = df_nocens, x = ~time, y = ~hazard, type = 'scatter', mode = 'lines',
            line = list(color = 'blue', width = 2), name = "Sans censure",
            legendgroup = "nocens", showlegend = TRUE) %>%
  # Ribbon Avec censure
  add_ribbons(data = df_cens, x = ~time, ymin = ~lower, ymax = ~upper,
              fillcolor = 'rgba(0,128,0,0.2)', line = list(color = 'transparent'),
              legendgroup = "cens", showlegend = FALSE) %>%
  # Courbe centrale Avec censure
  add_trace(data = df_cens, x = ~time, y = ~hazard, type = 'scatter', mode = 'lines',
            line = list(color = 'darkgreen', width = 2), name = "Avec censure",
            legendgroup = "cens", showlegend = TRUE) %>%
  layout(
    title = "Risque instantan√© Nelson-Aalen avec IC 95%",
    xaxis = list(title = "Dur√©e du mariage (ann√©es)"),
    yaxis = list(title = "Taux de risque h(t)"),
    legend = list(orientation = "v", x = 0.1, y = 1)
  )

div(style = "text-align:center;", fig)

```