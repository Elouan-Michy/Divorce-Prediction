"Niveau de stress financier","Infid√©lit√© survenue","A suivi un counseling",
"Soutien social","Nombre de hobbies partag√©s","Type de mariage",
"Cohabitation avant mariage","Historique de violence domestique","Score de confiance")
Type <- c("Quantitative","Quantitative","Qualitative","Quantitative","Qualitative",
"Qualitative","Quantitative","Qualitative","Qualitative","Quantitative",
"Quantitative","Qualitative","Qualitative","Quantitative","Qualitative",
"Qualitative","Quantitative","Quantitative","Qualitative","Qualitative",
"Qualitative","Quantitative")
Sous_type = c("Discr√®te","Discr√®te","Binaire","Discr√®te","Ordinale",
"Nominale","Continue","Nominale","Binaire","Continue",
"Discr√®te","Nominale","Binaire","Continue","Binaire",
"Binaire","Continue","Discr√®te","Nominale","Binaire",
"Binaire","Continue")
variables <- data.frame(
Nom_de_la_variable,
Description,
Type,
Sous_type,
stringsAsFactors = FALSE
)
# Fonction de coloration conditionnelle
variables <- variables %>%
mutate(
Type = cell_spec(Type,
background = ifelse(Type=="Quantitative","#5DADE2","#58D68D"),
color="black", bold=TRUE, escape=FALSE),
Sous_type = cell_spec(Sous_type,
background = case_when(
Sous_type == "Binaire"   ~ "#A3E4D7",  # vert menthe
Sous_type == "Discr√®te"  ~ "#85C1E9",  # bleu clair
Sous_type == "Ordinale"  ~ "#F7DC6F",  # jaune dor√©
Sous_type == "Nominale"  ~ "#F5B041",  # orange doux
Sous_type == "Continue"  ~ "#E59866"   # rouge ros√©
),
color = "black",
escape = FALSE)
)
# Affichage du tableau
kable(variables, "html", escape=FALSE, caption="üìä Tableau des variables avec code couleur") %>%
kable_styling(bootstrap_options = c("striped","hover","condensed"), full_width=FALSE) %>%
column_spec(1, bold=TRUE, color="black", background="#D6EAF8") %>%    # colonne Nom_de_la_variable
column_spec(2, width="8cm", bold=TRUE, background="#EBF5FB") %>%       # colonne Description
row_spec(0, bold=TRUE, color="white", background="#2C3E50")            # header
# Prendre que les variables quantitatives
vars_quanti <- Nom_de_la_variable[Type == "Quantitative"]
for (i in 0:4) {
# Grille 2 lignes √ó 5 colonnes
par(mfrow = c(1, 2), mar = c(4, 4, 3, 1))
for (j in 1:2) {
var_name <- vars_quanti[2*i+j]
boxplot(
data.brute[[var_name]],
main = var_name,
col = "#5DADE2",
boxwex = 0.5,
outline = TRUE,
cex.main = 0.9,
cex.axis = 0.9,
las = 1,
frame.plot = FALSE
)
grid(nx = NA, ny = NULL, col = "lightgray", lty = "dotted")
}
}
par(mfrow = c(1, 1))
# S√©lection des variables qualitatives
vars_quali <- Nom_de_la_variable[Type == "Qualitative"]
# Grille 2 lignes √ó 5 colonnes
par(mfrow = c(2, 6), mar = c(6, 4, 3, 1))
for (i in 0:5) {
# Grille 2 lignes √ó 5 colonnes
par(mfrow = c(1, 2), mar = c(6, 4, 3, 1))
for (j in 1:2) {
var_name <- vars_quali[2*i+j]
# Comptage des modalit√©s
counts <- table(data.brute[[var_name]])
# Titre avec retour √† la ligne si besoin
main_title <- gsub("_", "\n", var_name)
barplot(
counts,
main = main_title,
col = "#58D68D",
border = "gray25",
cex.main = 0.9,
cex.axis = 0.8,
cex.names = 0.7,       # taille des noms des modalit√©s
las = 2,               # rotation des labels pour qu‚Äôils soient lisibles
frame.plot = FALSE
)
grid(nx = NA, ny = NULL, col = "lightgray", lty = "dotted")
}
}
# ‚úÖ Revenir √† une seule figure
par(mfrow = c(1, 1))
## Donn√©e NON CENSURE
# Donn√©es dur√©e de mariage
mar_dur <- data.brute$age_at_marriage
n_dim = length(mar_dur)
# Dur√©e
t_values <- seq(1, max(mar_dur), by = 1)
S_estimate <- sapply(t_values, function(t) {
sum(mar_dur > t) / n_dim
})
## Donn√©e CENSUR√â
time <- data.brute$age_at_marriage
divorce <- data.brute$divorced  # 1 = divorce, 0 = censur√©
# Trier par temps
sorted_idx <- order(time)
time_sorted <- time[sorted_idx]
divorce_sorted <- divorce[sorted_idx]
n <- length(time_sorted)
S <- numeric(n)       # stocke la survie √† chaque temps
surv_prob <- 1         # survie initiale = 1
for(i in 1:n){
if(divorce_sorted[i] == 1){
# nombre √† risque : tous les individus >= temps actuel
n_risk <- sum(time_sorted >= time_sorted[i])
# mise √† jour survie
surv_prob <- surv_prob * (1 - 1 / n_risk)
}
S[i] <- surv_prob
}
# Plot initial vide avec limites
plot(NA, xlim = c(min(t_values), max(t_values)), ylim = c(0,1),
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "S(t) = Probabilit√© de rester mari√©",
main = "Comparaison fonction de survie")
# Ajouter l'escalier
lines(t_values, S_estimate, type = "s", col = "blue", lwd = 2)
lines(time_sorted, S, type = "s", col = "red", lwd = 2)
# L√©gende
legend("topright", legend = c("Sans censure", "Avec censure"),
col = c("blue", "red"), lwd = 2)
# Plot initial vide avec limites
plot(NA, xlim = c(1, max(t_values)), ylim = c(0,5),
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "H(t) = Risque cumul√©e",
main = "Comparaison fonction de risque cumul√©")
H_estimate = -log(S_estimate)
H = -log(S)
# Ajouter l'escalier
lines(t_values, H_estimate, type = "s", col = "blue", lwd = 2)
lines(time_sorted, H, type = "s", col = "red", lwd = 2)
# L√©gende
legend("topleft", legend = c("Sans censure", "Avec censure"),
col = c("blue", "red"), lwd = 2)
# Plot initial vide avec limites
plot(NA, xlim = c(1, max(t_values)), ylim = c(0,2),
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "h(t) = Risque instantan√©",
main = "Comparaison fonction de risque instantan√©")
# hazard h(t_i) ‚âà (H(t_i) - H(t_{i-1})) / (t_i - t_{i-1})
h_estimate <- c(NA, diff(H_estimate) / diff(t_values))
H_stable <- H
H_stable[is.infinite(H_stable)] <- max(H_stable[is.finite(H_stable)])
# enlever les doublons dans time_sorted
unique_idx <- !duplicated(time_sorted)
time_unique <- time_sorted[unique_idx]
H_unique <- H_stable[unique_idx]
H_spline <- splinefun(time_sorted, H_stable, method="natural")
h <- H_spline(time_sorted, deriv = 1)
h_discrete <- c(NA, diff(H_unique)/diff(time_unique))
# Ajouter l'escalier
lines(t_values, h_estimate, type = "s", col = "blue", lwd = 2)
lines(time_sorted, h, type = "s", col = "red", lwd = 2)
# L√©gende
legend("topleft", legend = c("Sans censure", "Avec censure"),
col = c("blue", "red"), lwd = 2)
## Donn√©e NON CENSURE
variable_time <- data.brute$marriage_duration_years
# Donn√©es dur√©e de mariage
mar_dur <- variable_time
n_dim = length(mar_dur)
# Dur√©e
t_values <- seq(1, max(mar_dur), by = 1)
S_estimate <- sapply(t_values, function(t) {
sum(mar_dur > t) / n_dim
})
## Donn√©e CENSUR√â
time <- variable_time
divorce <- data.brute$divorced  # 1 = divorce, 0 = censur√©
# Trier par temps
sorted_idx <- order(time)
time_sorted <- time[sorted_idx]
divorce_sorted <- divorce[sorted_idx]
n <- length(time_sorted)
S <- numeric(n)       # stocke la survie √† chaque temps
surv_prob <- 1         # survie initiale = 1
for(i in 1:n){
if(divorce_sorted[i] == 1){
# nombre √† risque : tous les individus >= temps actuel
n_risk <- sum(time_sorted >= time_sorted[i])
# mise √† jour survie
surv_prob <- surv_prob * (1 - 1 / n_risk)
}
S[i] <- surv_prob
}
# Plot initial vide avec limites
plot(NA, xlim = c(min(t_values), max(t_values)), ylim = c(0,1),
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "S(t) = Probabilit√© de rester mari√©",
main = "Comparaison fonction de survie")
# Ajouter l'escalier
lines(t_values, S_estimate, type = "s", col = "blue", lwd = 2)
lines(time_sorted, S, type = "s", col = "red", lwd = 2)
# L√©gende
legend("topright", legend = c("Sans censure", "Avec censure"),
col = c("blue", "red"), lwd = 2)
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
#install.packages("knitr")
#install.packages("kableExtra")
#install.packages("dplyr")
library(knitr)
library(kableExtra)
library(dplyr)
data.brute <- read.csv("divorce_df.csv")
dimension <- dim(data.brute)
n <- dimension[1]
p <- dimension[2]
# Cr√©ation du dataframe
Nom_de_la_variable <- c("age_at_marriage","marriage_duration_years","divorced","num_children",
"education_level","employment_status","combined_income",
"religious_compatibility","cultural_background_match","communication_score",
"conflict_frequency","conflict_resolution_style","mental_health_issues",
"financial_stress_level","infidelity_occurred","counseling_attended",
"social_support","shared_hobbies_count","marriage_type",
"pre_marital_cohabitation","domestic_violence_history","trust_score")
Description <- c("√Çge au mariage","Dur√©e du mariage","Divorce (oui/non)","Nombre d‚Äôenfants",
"Niveau d‚Äô√©ducation","Statut professionnel","Revenu combin√©",
"Compatibilit√© religieuse","Correspondance culturelle","Score de communication",
"Fr√©quence des conflits","Style de r√©solution de conflit","Probl√®mes de sant√© mentale",
"Niveau de stress financier","Infid√©lit√© survenue","A suivi un counseling",
"Soutien social","Nombre de hobbies partag√©s","Type de mariage",
"Cohabitation avant mariage","Historique de violence domestique","Score de confiance")
Type <- c("Quantitative","Quantitative","Qualitative","Quantitative","Qualitative",
"Qualitative","Quantitative","Qualitative","Qualitative","Quantitative",
"Quantitative","Qualitative","Qualitative","Quantitative","Qualitative",
"Qualitative","Quantitative","Quantitative","Qualitative","Qualitative",
"Qualitative","Quantitative")
Sous_type = c("Discr√®te","Discr√®te","Binaire","Discr√®te","Ordinale",
"Nominale","Continue","Nominale","Binaire","Continue",
"Discr√®te","Nominale","Binaire","Continue","Binaire",
"Binaire","Continue","Discr√®te","Nominale","Binaire",
"Binaire","Continue")
variables <- data.frame(
Nom_de_la_variable,
Description,
Type,
Sous_type,
stringsAsFactors = FALSE
)
# Fonction de coloration conditionnelle
variables <- variables %>%
mutate(
Type = cell_spec(Type,
background = ifelse(Type=="Quantitative","#5DADE2","#58D68D"),
color="black", bold=TRUE, escape=FALSE),
Sous_type = cell_spec(Sous_type,
background = case_when(
Sous_type == "Binaire"   ~ "#A3E4D7",  # vert menthe
Sous_type == "Discr√®te"  ~ "#85C1E9",  # bleu clair
Sous_type == "Ordinale"  ~ "#F7DC6F",  # jaune dor√©
Sous_type == "Nominale"  ~ "#F5B041",  # orange doux
Sous_type == "Continue"  ~ "#E59866"   # rouge ros√©
),
color = "black",
escape = FALSE)
)
# Affichage du tableau
kable(variables, "html", escape=FALSE, caption="üìä Tableau des variables avec code couleur") %>%
kable_styling(bootstrap_options = c("striped","hover","condensed"), full_width=FALSE) %>%
column_spec(1, bold=TRUE, color="black", background="#D6EAF8") %>%    # colonne Nom_de_la_variable
column_spec(2, width="8cm", bold=TRUE, background="#EBF5FB") %>%       # colonne Description
row_spec(0, bold=TRUE, color="white", background="#2C3E50")            # header
# Prendre que les variables quantitatives
vars_quanti <- Nom_de_la_variable[Type == "Quantitative"]
for (i in 0:4) {
# Grille 2 lignes √ó 5 colonnes
par(mfrow = c(1, 2), mar = c(4, 4, 3, 1))
for (j in 1:2) {
var_name <- vars_quanti[2*i+j]
boxplot(
data.brute[[var_name]],
main = var_name,
col = "#5DADE2",
boxwex = 0.5,
outline = TRUE,
cex.main = 0.9,
cex.axis = 0.9,
las = 1,
frame.plot = FALSE
)
grid(nx = NA, ny = NULL, col = "lightgray", lty = "dotted")
}
}
par(mfrow = c(1, 1))
# S√©lection des variables qualitatives
vars_quali <- Nom_de_la_variable[Type == "Qualitative"]
# Grille 2 lignes √ó 5 colonnes
par(mfrow = c(2, 6), mar = c(6, 4, 3, 1))
for (i in 0:5) {
# Grille 2 lignes √ó 5 colonnes
par(mfrow = c(1, 2), mar = c(6, 4, 3, 1))
for (j in 1:2) {
var_name <- vars_quali[2*i+j]
# Comptage des modalit√©s
counts <- table(data.brute[[var_name]])
# Titre avec retour √† la ligne si besoin
main_title <- gsub("_", "\n", var_name)
barplot(
counts,
main = main_title,
col = "#58D68D",
border = "gray25",
cex.main = 0.9,
cex.axis = 0.8,
cex.names = 0.7,       # taille des noms des modalit√©s
las = 2,               # rotation des labels pour qu‚Äôils soient lisibles
frame.plot = FALSE
)
grid(nx = NA, ny = NULL, col = "lightgray", lty = "dotted")
}
}
# ‚úÖ Revenir √† une seule figure
par(mfrow = c(1, 1))
## Donn√©e NON CENSURE
variable_time <- data.brute$marriage_duration_years
# Donn√©es dur√©e de mariage
mar_dur <- variable_time
n_dim = length(mar_dur)
# Dur√©e
t_values <- seq(1, max(mar_dur), by = 1)
S_estimate <- sapply(t_values, function(t) {
sum(mar_dur > t) / n_dim
})
## Donn√©e CENSUR√â
time <- variable_time
divorce <- data.brute$divorced  # 1 = divorce, 0 = censur√©
# Trier par temps
sorted_idx <- order(time)
time_sorted <- time[sorted_idx]
divorce_sorted <- divorce[sorted_idx]
n <- length(time_sorted)
S <- numeric(n)       # stocke la survie √† chaque temps
surv_prob <- 1         # survie initiale = 1
for(i in 1:n){
if(divorce_sorted[i] == 1){
# nombre √† risque : tous les individus >= temps actuel
n_risk <- sum(time_sorted >= time_sorted[i])
# mise √† jour survie
surv_prob <- surv_prob * (1 - 1 / n_risk)
}
S[i] <- surv_prob
}
# Plot initial vide avec limites
plot(NA, xlim = c(min(t_values), max(t_values)), ylim = c(0,1),
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "S(t) = Probabilit√© de rester mari√©",
main = "Comparaison fonction de survie")
# Ajouter l'escalier
lines(t_values, S_estimate, type = "s", col = "blue", lwd = 2)
lines(time_sorted, S, type = "s", col = "red", lwd = 2)
# L√©gende
legend("topright", legend = c("Sans censure", "Avec censure"),
col = c("blue", "red"), lwd = 2)
# Plot initial vide avec limites
plot(NA, xlim = c(1, max(t_values)), ylim = c(0,5),
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "H(t) = Risque cumul√©e",
main = "Comparaison fonction de risque cumul√©")
H_estimate = -log(S_estimate)
H = -log(S)
# Ajouter l'escalier
lines(t_values, H_estimate, type = "s", col = "blue", lwd = 2)
lines(time_sorted, H, type = "s", col = "red", lwd = 2)
# L√©gende
legend("topleft", legend = c("Sans censure", "Avec censure"),
col = c("blue", "red"), lwd = 2)
# Plot initial vide avec limites
plot(NA, xlim = c(1, max(t_values)), ylim = c(0,2),
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "h(t) = Risque instantan√©",
main = "Comparaison fonction de risque instantan√©")
# hazard h(t_i) ‚âà (H(t_i) - H(t_{i-1})) / (t_i - t_{i-1})
h_estimate <- c(NA, diff(H_estimate) / diff(t_values))
H_stable <- H
H_stable[is.infinite(H_stable)] <- max(H_stable[is.finite(H_stable)])
# enlever les doublons dans time_sorted
unique_idx <- !duplicated(time_sorted)
time_unique <- time_sorted[unique_idx]
H_unique <- H_stable[unique_idx]
H_spline <- splinefun(time_sorted, H_stable, method="natural")
h <- H_spline(time_sorted, deriv = 1)
h_discrete <- c(NA, diff(H_unique)/diff(time_unique))
# Ajouter l'escalier
lines(t_values, h_estimate, type = "s", col = "blue", lwd = 2)
lines(time_sorted, h, type = "s", col = "red", lwd = 2)
# L√©gende
legend("topleft", legend = c("Sans censure", "Avec censure"),
col = c("blue", "red"), lwd = 2)
## Donn√©e NON CENSURE
variable_time <- data.brute$marriage_duration_years
# Donn√©es dur√©e de mariage
mar_dur <- variable_time
n_dim = length(mar_dur)
# Dur√©e
t_values <- seq(1, max(mar_dur), by = 1)
S_estimate <- sapply(t_values, function(t) {
sum(mar_dur = t) / n_dim
})
## Donn√©e CENSUR√â
time <- variable_time
divorce <- data.brute$divorced  # 1 = divorce, 0 = censur√©
# Trier par temps
sorted_idx <- order(time)
time_sorted <- time[sorted_idx]
divorce_sorted <- divorce[sorted_idx]
n <- length(time_sorted)
S <- numeric(n)       # stocke la survie √† chaque temps
surv_prob <- 1         # survie initiale = 1
for(i in 1:n){
if(divorce_sorted[i] == 1){
# nombre √† risque : tous les individus >= temps actuel
n_risk <- sum(time_sorted = time_sorted[i])
# mise √† jour survie
surv_prob <- surv_prob * (1 - 1 / n_risk)
}
S[i] <- surv_prob
}
# Plot initial vide avec limites
plot(NA, xlim = c(min(t_values), max(t_values)), ylim = c(0,1),
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "S(t) = Probabilit√© de rester mari√©",
main = "Comparaison fonction de survie")
# Ajouter l'escalier
lines(t_values, S_estimate, type = "s", col = "blue", lwd = 2)
lines(time_sorted, S, type = "s", col = "red", lwd = 2)
# L√©gende
legend("topright", legend = c("Sans censure", "Avec censure"),
col = c("blue", "red"), lwd = 2)
## Donn√©e NON CENSURE
variable_time <- data.brute$marriage_duration_years
# Donn√©es dur√©e de mariage
mar_dur <- variable_time
n_dim = length(mar_dur)
# Dur√©e
t_values <- seq(1, max(mar_dur), by = 1)
S_estimate <- sapply(t_values, function(t) {
sum(mar_dur > t) / n_dim
})
## Donn√©e CENSUR√â
time <- variable_time
divorce <- data.brute$divorced  # 1 = divorce, 0 = censur√©
# Trier par temps
sorted_idx <- order(time)
time_sorted <- time[sorted_idx]
divorce_sorted <- divorce[sorted_idx]
n <- length(time_sorted)
S <- numeric(n)       # stocke la survie √† chaque temps
surv_prob <- 1         # survie initiale = 1
for(i in 1:n){
if(divorce_sorted[i] == 1){
# nombre √† risque : tous les individus >= temps actuel
n_risk <- sum(time_sorted >= time_sorted[i])
# mise √† jour survie
surv_prob <- surv_prob * (1 - 1 / n_risk)
}
S[i] <- surv_prob
}
# Plot initial vide avec limites
plot(NA, xlim = c(min(t_values), max(t_values)), ylim = c(0,1),
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "S(t) = Probabilit√© de rester mari√©",
main = "Comparaison fonction de survie")
# Ajouter l'escalier
lines(t_values, S_estimate, type = "s", col = "blue", lwd = 2)
lines(time_sorted, S, type = "s", col = "red", lwd = 2)
# L√©gende
legend("topright", legend = c("Sans censure", "Avec censure"),
col = c("blue", "red"), lwd = 2)
# Plot initial vide avec limites
plot(NA, xlim = c(1, max(t_values)), ylim = c(0,0.5),
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "h(t) = Risque instantan√©",
main = "Comparaison fonction de risque instantan√©")
# hazard h(t_i) ‚âà (H(t_i) - H(t_{i-1})) / (t_i - t_{i-1})
h_estimate <- c(NA, diff(H_estimate) / diff(t_values))
H_stable <- H
H_stable[is.infinite(H_stable)] <- max(H_stable[is.finite(H_stable)])
# enlever les doublons dans time_sorted
unique_idx <- !duplicated(time_sorted)
time_unique <- time_sorted[unique_idx]
H_unique <- H_stable[unique_idx]
H_spline <- splinefun(time_sorted, H_stable, method="natural")
h <- H_spline(time_sorted, deriv = 1)
h_discrete <- c(NA, diff(H_unique)/diff(time_unique))
# Ajouter l'escalier
lines(t_values, h_estimate, type = "s", col = "blue", lwd = 2)
lines(time_sorted, h, type = "s", col = "red", lwd = 2)
# L√©gende
legend("topleft", legend = c("Sans censure", "Avec censure"),
col = c("blue", "red"), lwd = 2)
max(h)
max(h, h_estimate)
max(h_estimate)
max(h, h_estimate, na.rm = TRUE)
max(h, h_estimate, na.rm = TRUE, Inf.rm = TRUE
)
