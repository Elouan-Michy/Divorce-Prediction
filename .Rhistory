# Revenir √† 1 figure
par(mfrow = c(1, 1))
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
suppressPackageStartupMessages(source("setup.R"))
# D√©finition des colonnes
fonctions <- c("$S(t)$", "$H(t)$", "$h(t)$")
definitions <- c(
"$S(t) = P(T \\geq t)$",
"$H(t) = \\int_0^t h(u)\\,du = -\\ln S(t)$",
"$h(t) = \\dfrac{f(t)}{S(t)} = -\\dfrac{S'(t)}{S(t)}$"
)
premier_temps <- c(
"Probabilit√© que le mariage dure ‚â• t",
"Risque cumul√© de divorce jusqu‚Äô√† t",
"Risque instantan√© de divorce √† t"
)
second_temps <- c(
"Probabilit√© de rester mari√© si mari√© √† l‚Äô√¢ge t",
"Risque cumul√© de divorce selon √¢ge au mariage ‚â§ t",
"Risque instantan√© de divorce pour un √¢ge de mariage t"
)
# Cr√©ation du tableau
tableau <- data.frame(
Fonction = fonctions,
D√©finition = definitions,
Dur√©e_du_mariage = premier_temps,
√Çge_au_mariage = second_temps,
stringsAsFactors = FALSE
)
# Affichage avec kable
kable(tableau, "html", caption = "üìä Interpr√©tation et d√©finitions des fonctions de survie", align = c("c","c","c","c")) %>%
kable_styling(
bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE
) %>%
column_spec(1, bold = TRUE, background = "#D6EAF8") %>%
column_spec(2, background = "#EBF5FB") %>%
column_spec(3, background = "#FDEBD0") %>%
column_spec(4, background = "#FCF3CF") %>%
row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")
# --- Donn√©es
time <- data.brute$marriage_duration_years
event <- data.brute$divorced
# --- 1Ô∏è‚É£ SANS CENSURE
surv_no_censor <- survfit(Surv(time, rep(1,length(time))) ~ 1)
summary(surv_no_censor)
# --- 2Ô∏è‚É£ AVEC CENSURE
surv_censor <- survfit(Surv(time, event) ~ 1)
summary(surv_censor)
# --- 3Ô∏è‚É£ PLOT COMPARATIF avec intervalle de confiance
# --- Plot comparatif avec intervalle de confiance
ggsurvplot_combine(
list("Sans censure" = surv_no_censor, "Avec censure" = surv_censor),
combine = TRUE,
conf.int = TRUE,                   # activer l'intervalle de confiance
conf.int.alpha = 0.25,             # transparence de la bande
legend.title = NULL,
legend.labs = c("Sans censure", "Avec censure"),
palette = c("#1f78b4", "#e31a1c"), # bleu et rouge plus doux
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "Probabilit√© de rester mari√©",
title = "Comparaison des fonctions de survie : sans et avec censure",
surv.median.line = "hv",           # ligne m√©diane horizontale/verticale
risk.table.height = 0.25,
ggtheme = theme_minimal(base_size = 14) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
legend.position = "top",
legend.text = element_text(size = 12)
)
)
# Assurer que education_level est bien un facteur avec des niveaux lisibles
data.brute$education_level <- factor(data.brute$education_level,
levels = unique(data.brute$education_level))
# Cox univari√©
cox_edu <- coxph(Surv(marriage_duration_years, divorced) ~ education_level,
data = data.brute)
# Pr√©parer une data.frame avec chaque niveau pour la pr√©diction
newdata_edu <- data.frame(education_level = levels(data.brute$education_level))
# Estimation de la survie par niveau
surv_fit_edu <- survfit(cox_edu, newdata = newdata_edu)
# Palette automatique adapt√©e au nombre de groupes
n_levels <- length(levels(data.brute$education_level))
colors <- c("red", "blue", "green", "purple", "orange")  # 5 groupes
# Plot avec survminer
ggsurvplot(
surv_fit_edu,
data = data.brute,
conf.int = FALSE,
legend.title = "",
legend.labs = levels(data.brute$education_level),  # <-- l√©gende lisible
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "Probabilit√© de rester mari√©",
palette = colors,
surv.median.line = "hv", # ligne horizontale/verticale pour la m√©diane
ggtheme = theme_minimal(base_size = 14)
)
# Assurer que education_level est bien un facteur avec des niveaux lisibles
data.brute$mental_health_issues <- factor(data.brute$mental_health_issues,
levels = unique(data.brute$mental_health_issues))
# Cox univari√©
cox_edu <- coxph(Surv(marriage_duration_years, divorced) ~ mental_health_issues,
data = data.brute)
# Pr√©parer une data.frame avec chaque niveau pour la pr√©diction
newdata_edu <- data.frame(mental_health_issues = levels(data.brute$mental_health_issues))
# Estimation de la survie par niveau
surv_fit_edu <- survfit(cox_edu, newdata = newdata_edu)
# Palette automatique adapt√©e au nombre de groupes
n_levels <- length(levels(data.brute$mental_health_issues))
colors <- c("red", "blue")  # 3 groupes
# Plot avec survminer
ggsurvplot(
surv_fit_edu,
data = data.brute,
conf.int = FALSE,
legend.title = "",
legend.labs = levels(data.brute$mental_health_issues),  # <-- l√©gende lisible
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "Probabilit√© de rester mari√©",
palette = colors,
surv.median.line = "hv", # ligne horizontale/verticale pour la m√©diane
ggtheme = theme_minimal(base_size = 14)
)
# Assurer que education_level est bien un facteur avec des niveaux lisibles
data.brute$infidelity_occurred <- factor(data.brute$infidelity_occurred,
levels = unique(data.brute$infidelity_occurred))
# Cox univari√©
cox_edu <- coxph(Surv(marriage_duration_years, divorced) ~ infidelity_occurred,
data = data.brute)
# Pr√©parer une data.frame avec chaque niveau pour la pr√©diction
newdata_edu <- data.frame(infidelity_occurred = levels(data.brute$infidelity_occurred))
# Estimation de la survie par niveau
surv_fit_edu <- survfit(cox_edu, newdata = newdata_edu)
# Palette automatique adapt√©e au nombre de groupes
n_levels <- length(levels(data.brute$infidelity_occurred))
colors <- c("red", "blue")  # 3 groupes
# Plot avec survminer
ggsurvplot(
surv_fit_edu,
data = data.brute,
conf.int = FALSE,
legend.title = "",
legend.labs = levels(data.brute$infidelity_occurred),  # <-- l√©gende lisible
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "Probabilit√© de rester mari√©",
palette = colors,
surv.median.line = "hv", # ligne horizontale/verticale pour la m√©diane
ggtheme = theme_minimal(base_size = 14)
)
# Assurer que education_level est bien un facteur avec des niveaux lisibles
data.brute$marriage_type <- factor(data.brute$marriage_type,
levels = unique(data.brute$marriage_type))
# Cox univari√©
cox_edu <- coxph(Surv(marriage_duration_years, divorced) ~ marriage_type,
data = data.brute)
# Pr√©parer une data.frame avec chaque niveau pour la pr√©diction
newdata_edu <- data.frame(marriage_type = levels(data.brute$marriage_type))
# Estimation de la survie par niveau
surv_fit_edu <- survfit(cox_edu, newdata = newdata_edu)
# Palette automatique adapt√©e au nombre de groupes
n_levels <- length(levels(data.brute$marriage_type))
colors <- c("red", "blue", "green")  # 3 groupes
# Plot avec survminer
ggsurvplot(
surv_fit_edu,
data = data.brute,
conf.int = FALSE,
legend.title = "",
legend.labs = levels(data.brute$marriage_type),  # <-- l√©gende lisible
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "Probabilit√© de rester mari√©",
palette = colors,
surv.median.line = "hv", # ligne horizontale/verticale pour la m√©diane
ggtheme = theme_minimal(base_size = 14)
)
library(MASS)
# Mod√®le complet (tout inclure au d√©part)
full_model <- coxph(Surv(time, event) ~
marriage_type + infidelity_occurred + mental_health_issues + education_level +
employment_status + combined_income + religious_compatibility + cultural_background_match +
communication_score + conflict_frequency + conflict_resolution_style +
financial_stress_level + counseling_attended + social_support +
shared_hobbies_count + pre_marital_cohabitation + domestic_violence_history + trust_score,
data = data.brute)
# Mod√®le vide (intercept seulement)
null_model <- coxph(Surv(time, event) ~ 1, data = data.brute)
# S√©lection stepwise (AIC par d√©faut)
best_model <- stepAIC(null_model, scope = list(lower=null_model, upper=full_model), direction="both")
summary(best_model)
# Cr√©ation du tableau
risk_methods <- data.frame(
M√©thode = c("Breslow", "Nelson-Aalen", "Cox avec covariables (Breslow)"),
Formule = c(
"$H(t) = -\\ln \\hat{S}(t)$",
"$\\hat{H}_{NA}(t) = \\sum_{t_i \\le t} \\dfrac{d_i}{n_i}$",
"$\\hat{H}_{Breslow}(t) = \\sum_{t_i \\le t} \\dfrac{d_i}{\\sum_{j \\in R(t_i)} e^{\\beta^T X_j}}$"
),
Description = c(
"Transformation directe de la fonction de survie Kaplan-Meier. Non param√©trique et simple.",
"Estimateur non param√©trique bas√© sur les √©v√©nements observ√©s et le nombre de sujets √† risque.",
"Risque cumulatif estim√© √† partir d‚Äôun mod√®le de Cox avec covariables. Breslow g√®re les √©v√©nements multiples au m√™me temps."
),
stringsAsFactors = FALSE
)
# Affichage avec kable et style
kable(risk_methods, "html", escape = FALSE, caption = "üìä M√©thodes d‚Äôestimation du risque cumulatif", align = c("c","c","c")) %>%
kable_styling(bootstrap_options = c("striped","hover","condensed"), full_width = FALSE) %>%
column_spec(1, bold = TRUE, color = "black", background = "#D6EAF8") %>%
column_spec(2, width = "6cm") %>%
column_spec(3, width = "8cm") %>%
row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")
# --- Donn√©es
time <- data.brute$marriage_duration_years
event <- data.brute$divorced
# --- 1Ô∏è‚É£ Kaplan-Meier
km_fit <- survfit(Surv(time, event) ~ 1)
df_km <- data.frame(
time = km_fit$time,
H = -log(km_fit$surv)
)
# --- 2Ô∏è‚É£ Nelson-Aalen
# H(t) = sum(d_i / n_i)
na_fit <- survfit(Surv(time, event) ~ 1, type="fleming")  # Fleming-Harrington = Nelson-Aalen
df_na <- data.frame(
time = na_fit$time,
H = na_fit$cumhaz
)
# --- Fusionner pour ggplot
df_all <- bind_rows(
df_km %>% mutate(Method = "Breslow"),
df_na %>% mutate(Method = "Nelson-Aalen")
)
# --- Plot
ggplot(df_all, aes(x = time, y = H, color = Method)) +
geom_step(size = 1.2) +
scale_color_manual(values = c("blue","red")) +
labs(
title = "Comparaison des fonctions de risque cumul√©e",
x = "Dur√©e du mariage (ann√©es)",
y = "H(t) = Risque cumulatif",
color = "M√©thode"
) +
theme_minimal(base_size = 14) +
theme(
plot.title = element_text(hjust = 0.5),
legend.position = "top"
)
library(survival)
library(survminer)
# --- Cr√©er objet Surv
time <- data.brute$marriage_duration_years
event <- data.brute$divorced  # 1=divorc√©, 0=censur√©
surv_obj <- Surv(time, event)
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
suppressPackageStartupMessages(source("setup.R"))
# D√©finition des colonnes
fonctions <- c("$S(t)$", "$H(t)$", "$h(t)$")
definitions <- c(
"$S(t) = P(T \\geq t)$",
"$H(t) = \\int_0^t h(u)\\,du = -\\ln S(t)$",
"$h(t) = \\dfrac{f(t)}{S(t)} = -\\dfrac{S'(t)}{S(t)}$"
)
premier_temps <- c(
"Probabilit√© que le mariage dure ‚â• t",
"Risque cumul√© de divorce jusqu‚Äô√† t",
"Risque instantan√© de divorce √† t"
)
second_temps <- c(
"Probabilit√© de rester mari√© si mari√© √† l‚Äô√¢ge t",
"Risque cumul√© de divorce selon √¢ge au mariage ‚â§ t",
"Risque instantan√© de divorce pour un √¢ge de mariage t"
)
# Cr√©ation du tableau
tableau <- data.frame(
Fonction = fonctions,
D√©finition = definitions,
Dur√©e_du_mariage = premier_temps,
√Çge_au_mariage = second_temps,
stringsAsFactors = FALSE
)
# Affichage avec kable
kable(tableau, "html", caption = "üìä Interpr√©tation et d√©finitions des fonctions de survie", align = c("c","c","c","c")) %>%
kable_styling(
bootstrap_options = c("striped", "hover", "condensed"),
full_width = FALSE
) %>%
column_spec(1, bold = TRUE, background = "#D6EAF8") %>%
column_spec(2, background = "#EBF5FB") %>%
column_spec(3, background = "#FDEBD0") %>%
column_spec(4, background = "#FCF3CF") %>%
row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")
# --- Donn√©es
time <- data.brute$marriage_duration_years
event <- data.brute$divorced
# --- 1Ô∏è‚É£ SANS CENSURE
surv_no_censor <- survfit(Surv(time, rep(1,length(time))) ~ 1)
summary(surv_no_censor)
# --- 2Ô∏è‚É£ AVEC CENSURE
surv_censor <- survfit(Surv(time, event) ~ 1)
summary(surv_censor)
# --- 3Ô∏è‚É£ PLOT COMPARATIF avec intervalle de confiance
# --- Plot comparatif avec intervalle de confiance
ggsurvplot_combine(
list("Sans censure" = surv_no_censor, "Avec censure" = surv_censor),
combine = TRUE,
conf.int = TRUE,                   # activer l'intervalle de confiance
conf.int.alpha = 0.25,             # transparence de la bande
legend.title = NULL,
legend.labs = c("Sans censure", "Avec censure"),
palette = c("#1f78b4", "#e31a1c"), # bleu et rouge plus doux
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "Probabilit√© de rester mari√©",
title = "Comparaison des fonctions de survie : sans et avec censure",
surv.median.line = "hv",           # ligne m√©diane horizontale/verticale
risk.table.height = 0.25,
ggtheme = theme_minimal(base_size = 14) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold", size = 16),
legend.position = "top",
legend.text = element_text(size = 12)
)
)
# Assurer que education_level est bien un facteur avec des niveaux lisibles
data.brute$education_level <- factor(data.brute$education_level,
levels = unique(data.brute$education_level))
# Cox univari√©
cox_edu <- coxph(Surv(marriage_duration_years, divorced) ~ education_level,
data = data.brute)
# Pr√©parer une data.frame avec chaque niveau pour la pr√©diction
newdata_edu <- data.frame(education_level = levels(data.brute$education_level))
# Estimation de la survie par niveau
surv_fit_edu <- survfit(cox_edu, newdata = newdata_edu)
# Palette automatique adapt√©e au nombre de groupes
n_levels <- length(levels(data.brute$education_level))
colors <- c("red", "blue", "green", "purple", "orange")  # 5 groupes
# Plot avec survminer
ggsurvplot(
surv_fit_edu,
data = data.brute,
conf.int = FALSE,
legend.title = "",
legend.labs = levels(data.brute$education_level),  # <-- l√©gende lisible
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "Probabilit√© de rester mari√©",
palette = colors,
surv.median.line = "hv", # ligne horizontale/verticale pour la m√©diane
ggtheme = theme_minimal(base_size = 14)
)
# Assurer que education_level est bien un facteur avec des niveaux lisibles
data.brute$mental_health_issues <- factor(data.brute$mental_health_issues,
levels = unique(data.brute$mental_health_issues))
# Cox univari√©
cox_edu <- coxph(Surv(marriage_duration_years, divorced) ~ mental_health_issues,
data = data.brute)
# Pr√©parer une data.frame avec chaque niveau pour la pr√©diction
newdata_edu <- data.frame(mental_health_issues = levels(data.brute$mental_health_issues))
# Estimation de la survie par niveau
surv_fit_edu <- survfit(cox_edu, newdata = newdata_edu)
# Palette automatique adapt√©e au nombre de groupes
n_levels <- length(levels(data.brute$mental_health_issues))
colors <- c("red", "blue")  # 3 groupes
# Plot avec survminer
ggsurvplot(
surv_fit_edu,
data = data.brute,
conf.int = FALSE,
legend.title = "",
legend.labs = levels(data.brute$mental_health_issues),  # <-- l√©gende lisible
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "Probabilit√© de rester mari√©",
palette = colors,
surv.median.line = "hv", # ligne horizontale/verticale pour la m√©diane
ggtheme = theme_minimal(base_size = 14)
)
# Assurer que education_level est bien un facteur avec des niveaux lisibles
data.brute$infidelity_occurred <- factor(data.brute$infidelity_occurred,
levels = unique(data.brute$infidelity_occurred))
# Cox univari√©
cox_edu <- coxph(Surv(marriage_duration_years, divorced) ~ infidelity_occurred,
data = data.brute)
# Pr√©parer une data.frame avec chaque niveau pour la pr√©diction
newdata_edu <- data.frame(infidelity_occurred = levels(data.brute$infidelity_occurred))
# Estimation de la survie par niveau
surv_fit_edu <- survfit(cox_edu, newdata = newdata_edu)
# Palette automatique adapt√©e au nombre de groupes
n_levels <- length(levels(data.brute$infidelity_occurred))
colors <- c("red", "blue")  # 3 groupes
# Plot avec survminer
ggsurvplot(
surv_fit_edu,
data = data.brute,
conf.int = FALSE,
legend.title = "",
legend.labs = levels(data.brute$infidelity_occurred),  # <-- l√©gende lisible
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "Probabilit√© de rester mari√©",
palette = colors,
surv.median.line = "hv", # ligne horizontale/verticale pour la m√©diane
ggtheme = theme_minimal(base_size = 14)
)
# Assurer que education_level est bien un facteur avec des niveaux lisibles
data.brute$marriage_type <- factor(data.brute$marriage_type,
levels = unique(data.brute$marriage_type))
# Cox univari√©
cox_edu <- coxph(Surv(marriage_duration_years, divorced) ~ marriage_type,
data = data.brute)
# Pr√©parer une data.frame avec chaque niveau pour la pr√©diction
newdata_edu <- data.frame(marriage_type = levels(data.brute$marriage_type))
# Estimation de la survie par niveau
surv_fit_edu <- survfit(cox_edu, newdata = newdata_edu)
# Palette automatique adapt√©e au nombre de groupes
n_levels <- length(levels(data.brute$marriage_type))
colors <- c("red", "blue", "green")  # 3 groupes
# Plot avec survminer
ggsurvplot(
surv_fit_edu,
data = data.brute,
conf.int = FALSE,
legend.title = "",
legend.labs = levels(data.brute$marriage_type),  # <-- l√©gende lisible
xlab = "Dur√©e du mariage (ann√©es)",
ylab = "Probabilit√© de rester mari√©",
palette = colors,
surv.median.line = "hv", # ligne horizontale/verticale pour la m√©diane
ggtheme = theme_minimal(base_size = 14)
)
library(MASS)
# Mod√®le complet (tout inclure au d√©part)
full_model <- coxph(Surv(time, event) ~
marriage_type + infidelity_occurred + mental_health_issues + education_level +
employment_status + combined_income + religious_compatibility + cultural_background_match +
communication_score + conflict_frequency + conflict_resolution_style +
financial_stress_level + counseling_attended + social_support +
shared_hobbies_count + pre_marital_cohabitation + domestic_violence_history + trust_score,
data = data.brute)
# Mod√®le vide (intercept seulement)
null_model <- coxph(Surv(time, event) ~ 1, data = data.brute)
# S√©lection stepwise (AIC par d√©faut)
best_model <- stepAIC(null_model, scope = list(lower=null_model, upper=full_model), direction="both")
summary(best_model)
# Cr√©ation du tableau
risk_methods <- data.frame(
M√©thode = c("Breslow", "Nelson-Aalen", "Cox avec covariables (Breslow)"),
Formule = c(
"$H(t) = -\\ln \\hat{S}(t)$",
"$\\hat{H}_{NA}(t) = \\sum_{t_i \\le t} \\dfrac{d_i}{n_i}$",
"$\\hat{H}_{Breslow}(t) = \\sum_{t_i \\le t} \\dfrac{d_i}{\\sum_{j \\in R(t_i)} e^{\\beta^T X_j}}$"
),
Description = c(
"Transformation directe de la fonction de survie Kaplan-Meier. Non param√©trique et simple.",
"Estimateur non param√©trique bas√© sur les √©v√©nements observ√©s et le nombre de sujets √† risque.",
"Risque cumulatif estim√© √† partir d‚Äôun mod√®le de Cox avec covariables. Breslow g√®re les √©v√©nements multiples au m√™me temps."
),
stringsAsFactors = FALSE
)
# Affichage avec kable et style
kable(risk_methods, "html", escape = FALSE, caption = "üìä M√©thodes d‚Äôestimation du risque cumulatif", align = c("c","c","c")) %>%
kable_styling(bootstrap_options = c("striped","hover","condensed"), full_width = FALSE) %>%
column_spec(1, bold = TRUE, color = "black", background = "#D6EAF8") %>%
column_spec(2, width = "6cm") %>%
column_spec(3, width = "8cm") %>%
row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")
# --- Donn√©es
time <- data.brute$marriage_duration_years
event <- data.brute$divorced
# --- 1Ô∏è‚É£ Kaplan-Meier
km_fit <- survfit(Surv(time, event) ~ 1)
df_km <- data.frame(
time = km_fit$time,
H = -log(km_fit$surv)
)
# --- 2Ô∏è‚É£ Nelson-Aalen
# H(t) = sum(d_i / n_i)
na_fit <- survfit(Surv(time, event) ~ 1, type="fleming")  # Fleming-Harrington = Nelson-Aalen
df_na <- data.frame(
time = na_fit$time,
H = na_fit$cumhaz
)
# --- Fusionner pour ggplot
df_all <- bind_rows(
df_km %>% mutate(Method = "Breslow"),
df_na %>% mutate(Method = "Nelson-Aalen")
)
# --- Plot
ggplot(df_all, aes(x = time, y = H, color = Method)) +
geom_step(size = 1.2) +
scale_color_manual(values = c("blue","red")) +
labs(
title = "Comparaison des fonctions de risque cumul√©e",
x = "Dur√©e du mariage (ann√©es)",
y = "H(t) = Risque cumulatif",
color = "M√©thode"
) +
theme_minimal(base_size = 14) +
theme(
plot.title = element_text(hjust = 0.5),
legend.position = "top"
)
library(survival)
library(survminer)
# --- Cr√©er objet Surv
time <- data.brute$marriage_duration_years
event <- data.brute$divorced  # 1=divorc√©, 0=censur√©
surv_obj <- Surv(time, event)
